<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Sparse Contrastive Principal Component Analysis for Exploring High-Dimensional Biological Data</title>
    <meta charset="utf-8" />
    <meta name="author" content="Philippe Boileau" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="font-size.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Sparse Contrastive Principal Component Analysis for Exploring High-Dimensional Biological Data
### Philippe Boileau
### Graduate Group in Biostatistics <br> University of California, Berkeley <br> In Collaboration with Nima Hejazi and Sandrine Dudoit

---

class: middle, center, inverse

# Motivation



???

First, we'll briefly motivate our dimensionality reduction method.

---
class: left, top

# Motivation

A common problem in the analysis of high-dimensional biological data is the
teasing out of biological signal from technical noise, i.e. the removal of
*unwanted* variation. 

.center[![:scale 60%](figures/batch_effect_example.png)]

???

As you well know, a common issues that arises in the analysis of high-dimensional biological data is the teasing out of meaningful signal from technical noise.
In this toy example over here, the first two principal components of some data
are presented. There are two distinct biological groups, one green, one purple, and
each group is split by a batch effect, where each observations' batch is denoted
by it's shape.

Before we analyze this data, we'll have to remove this batch effect. Now there
are plenty of options to do this, but many of them make some restrictive assumptions
about how this data has been generated. Instead, we'd like to remove this unwanted
variation without needing to make untenable assumptions. This is where our
scPCA method can be of use.

---
class: middle, center, inverse

# Background

???

Now, scPCA is simply the combination of two different dimensionality reduction
methods: contrastive PCA (or cPCA for short), and sparse PCA (referred to as SPCA).
I'll briefly introduce these two methods before going any further.

---
class: left, top

# cPCA

Given a **target** dataset containing both *wanted* and *unwanted* variation,
and a **background** dataset containing only *unwanted* variation, cPCA produces
a low-dimensional embedding of the target data reflecting (a portion of)
the variation not found in the background data.

.center[
![](figures/cPCA.png)

*Figure 1, &lt;a name=cite-Abid2018&gt;&lt;/a&gt;[Abid, Zhang, Bagaria, and Zou (2018)](#bib-Abid2018)*
]

???

cPCA provides its users with a novel approach for the removal of unwanted variation
by taking advantage of experimental design which generated the data. That is,
given a dataset which contains a wanted and unwanted variation, which we refer
to as the target, and a dataset containing only the unwanted variation, referred
to as the background data, we can deflate the unwanted variation in the target
data.

A sketch of how this is accomplished is nicely summarized in the first figure
of Abid and others, the developers of this method. First, the sample covariance
matrices of the target and background data are computed. Next, we take the
difference of the target's and background's sample covariance matrices, scaling
the background's matrix by a hyperparameter, known as the contrastive parameter.
We then get the eigendecomposition of the resulting symmetric matrix, the
contrastive matrix, and use the decomposition's loadings vectors to rotate the
target data. By appropriately tuning the contrastive parameter, we're effectively
able to remove the noise in the target.

In this example over here, we see that the first principal component corresponds
the red, dotted line. This axis of variation isn't all that interesting; it
won't separate the groups contained in the target data. However, the leading
cPCA will be able to deflate this un-interesting variation.

---
class: left, top

# Drawbacks

1. Like PCA in high dimensions, interpreting cPCA's loadings is difficult.
2. The contrastive parameter, `\(\alpha\)`, is selected visually.

.center[
![](figures/machine_learning.png)

*[xkcd.com/1838/](https://xkcd.com/1838/)*
]

???

Although, this is an interesting approach to the removal of unwanted variation,
there are a few issues. Namely, since this method is essentially PCA but applied
to a different covariance matrix, it suffers from the same issues as PCA does in
high dimensions. In particular, interpreting cPCA's loadings vectors, the vectors
that define the linear combinations of each contrastive principal component, is
quite difficult, and they are potentially unstable. Even worse, selecting the
appropriate contrastive parameter is accomplished through visual inspection. All
analyses are subjective to some degree, but this takes that to another level.

---
class: left, top

# SPCA

SPCA &lt;a name=cite-Zou2006&gt;&lt;/a&gt;([Zou, Hastie, and Tibshirani, 2006](#bib-Zou2006)) provides interpretable loadings that are more
stable in high dimensions. How is this accomplished?

--

1. Re-frame PCA as a regression problem: PCA produces a linear manifold
approximation of the data.
2. Extend elasticnet regression to this regression problem. That is, include
`\(\ell_1\)` and `\(\ell_2\)` penalty terms to induce sparsity in loadings vectors.

--

This second step isn't as straightforward as in the typical regression setting,
but it is possible to do it efficiently &lt;a name=cite-Erichson_2020&gt;&lt;/a&gt;([Erichson, Zheng, Manohar, Brunton, Kutz, and Aravkin, 2020](#bib-Erichson_2020)).

???

Based on these drawbacks, you probably see where I'm going with SPCA. For those
of you who aren't familiar with SPCA, it's a method originally developed by
Zou et al that increases the interpretability and stability of PCA in high
dimensional settings. 

This is accomplished by first re-framing PCA as a linear regression problem, and
then including L1 and L2 penalties in the objective function to induce sparsity
in the loadings vectors. This is analogous to an elasticnet regression. And
just like in classic elasticnet, lasso, and ridge regressions, the penalty
hyperparamters have to be selected somehow.

Now, this process isn't exactly as easy as I've let on, but there are some
very efficient numerical methods to solve this problem. One that we employ in our
package is that of Erichson and others.

---
class: middle, center, inverse

# Sparse Contrastive Principal Component Analysis (scPCA)

???

With the background done, we can finally talk about scPCA.

---
class: left, top

# scPCA

scPCA consists of applying SPCA on the contrastive covariance matrix of
target and background datasets. We get the best of both of cPCA and SPCA:

* Unwanted variation is removed from the target dataset
* scPCA's loadings are interpretable
* scPCA's loadings are stable

--

But what about the hyperparameters?

???

As I mentioned before, scPCA is essentially a combination of the cPCA and SPCA,
requiring only a few minor modifications required to make these methods well
together.

The result is a method sparse version of cPCA. That is, scPCA's are now
interpretable and stable in the high-dimensional settings that we so often
encounter when analyzing the data output by high-throughput assays.

However, we're note completely done. We still need to come up with a way to
select scPCA's hyperparameters: the contrastive parameters, and an L1 penalty
term that controls the levels of sparsity.

---
class: left, top

# Hyperparameter Tuning

There are two main hyperparameters in the scPCA algorithm:
+ The constrastive parameter `\(\alpha\)`
+ The `\(\ell_1\)`-penalty parameter `\(\lambda_1\)` 

Hyperparameters are selected via a clustering-based grid-search method:

1. A grid of hyperparameters is specified
2. scPCA is performed for each pair of hyperparameters
3. A clustering algorithm is applied to the resulting low-dimensional embedding
4. Each embedding's quality is evaluated via the average silhouette width

The pair of hyperparameters that results in the largest average silhouette width
are identified as *optimal*.

A cross-validated variation also exists if finding non-generalizable patterns
in the data is a concern.

???

This attempts to solve one of the main issues with cPCA and SPCA, and can in
fact be generalized to both. However, it assumes that there are clusters in
the high-dimensional space.

---
class: left, top

# Implementation

The `scPCA` R package, released in Bioconductor 3.10, implements:
1. scPCA
2. cPCA with automated hyperparameter tuning
3. cross-validated scPCA and cPCA
4. cPCA with visual hyperparameter tuning

--

### Relevant details:

+ The hyperparameter tuning framework is embarrassingly parallel. Methods 1, 2, and 3 posses parallelized counterparts, making use of the `BiocParallel` infrastructure.
+ The `scPCA` package integrates fully with the `SingleCellExperiment` container class, allowing for these methods' seamless inclusion in scRNA-seq analysis pipelines. 
+ The scPCA method is applied to a contrastive covariance matrix; its running time is impacted by the number of features, not observations.

---
class: middle, center, inverse

# Example

---
class: left, top

# Simulated scRNA-seq Data

300 cells and 500 genes were simulated using the `Splat` framework of
&lt;a name=cite-Zappia2017&gt;&lt;/a&gt;[Zappia, Phipson, and Oshlack (2017)](#bib-Zappia2017), and split into 3 equally sized groups.

.center[![:scale 60%](figures/full_sim_data.png)]

A number of leading dimensionality reduction methods were applied to the target
data to determine if they could disentangle the biological signal from the
batch effect.

???
Two groups had high levels of DE when compared to all others, making up the
target dataset, and the remaining group, which has low-levels of DE, makes up
the background data. A batch effect was included to mask the biological groups
in the target data.

---
class: left, top

# Simulated scRNA-seq Data (Cont.)

.center[![](figures/sim_results.png)]

---
class: left, top

# Simulated scRNA-seq Data (Cont.)

.center2[![:scale 200%](figures/sim_loadings.png)]

---
class: inverse, center, middle

# Fin.

See our paper, Exploring High-Dimensional Biological Data with Sparse
Contrastive Principal Component Analysis, for more information.

---
class: left, top

# References

&lt;a name=bib-Abid2018&gt;&lt;/a&gt;[Abid, A, M. J. Zhang, V. K. Bagaria, et
al.](#cite-Abid2018) (2018). "Exploring patterns enriched in a dataset
with contrastive principal component analysis". In: _Nature
Communications_ 9.1, p. 2134. ISSN: 2041-1723. DOI:
[10.1038/s41467-018-04608-8](https://doi.org/10.1038%2Fs41467-018-04608-8).
URL:
[http://www.nature.com/articles/s41467-018-04608-8](http://www.nature.com/articles/s41467-018-04608-8).

&lt;a name=bib-Erichson_2020&gt;&lt;/a&gt;[Erichson, N. B, P. Zheng, K. Manohar, et
al.](#cite-Erichson_2020) (2020). "Sparse Principal Component Analysis
via Variable Projection". In: _SIAM Journal on Applied Mathematics_
80.2, p. 977â€“1002. ISSN: 1095-712X. DOI:
[10.1137/18m1211350](https://doi.org/10.1137%2F18m1211350). URL:
[http://dx.doi.org/10.1137/18m1211350](http://dx.doi.org/10.1137/18m1211350).

&lt;a name=bib-Zappia2017&gt;&lt;/a&gt;[Zappia, L, B. Phipson, and A.
Oshlack](#cite-Zappia2017) (2017). "Splatter: simulation of single-cell
RNA sequencing data". In: _Genome Biology_ 18.1, p. 174. ISSN:
1474-760X. DOI:
[10.1186/s13059-017-1305-0](https://doi.org/10.1186%2Fs13059-017-1305-0).
URL:
[http://genomebiology.biomedcentral.com/articles/10.1186/s13059-017-1305-0](http://genomebiology.biomedcentral.com/articles/10.1186/s13059-017-1305-0).

&lt;a name=bib-Zou2006&gt;&lt;/a&gt;[Zou, H, T. Hastie, and R.
Tibshirani](#cite-Zou2006) (2006). "Sparse Principal Component
Analysis". In: _Journal of Computational and Graphical Statistics_
15.2, pp. 265-286. DOI:
[10.1198/106186006X113430](https://doi.org/10.1198%2F106186006X113430).
eprint: https://doi.org/10.1198/106186006X113430. URL:
[https://doi.org/10.1198/106186006X113430](https://doi.org/10.1198/106186006X113430).
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="addons/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
